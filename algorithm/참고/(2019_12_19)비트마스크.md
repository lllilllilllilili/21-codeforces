&, | = << 
&&, || = 논리합
작업을 모든 비트에 대해서 다한다. 
shift 연산을 쓴다. 
and = masking off
or = masking on

3 2 1 0
0 0 0 0 

밀려나가면 나가는 만큼 score를 올릴것이다. 
주자가 있다는것 ? = 타석에 선 주자를 놓는다. 

{ 0, 1, 2, 3, 4 } => 11111 => (2^4 * 1) + (2^3 * 1) + (2^2 * 1) + (2^1 * 1) + (2^0 * 1) = 31
{ 1, 2, 3, 4 } => 11110 => (2^4 * 1) + (2^3 * 1) + (2^2 * 1) + (2^1 * 1) = 30 
{ 1, 2, 4 } => 10110 => (2^4 * 1) + (2^2 * 1) + (2^1 * 1) = 22
{ 2, 4 } => 10100 => (2^4 * 1) + (2^2 * 1) = 20
{ 1 } => 00010 => (2^1 * 1) = 2


부분집합을 배열이 아닌 정수를 통해 나타낼 수 있게 된다.

즉, 20 이란 정수는 부분집합 { 2, 4 } 를 나타내는 것을 의미한다.

{ 2, 4 } 부분집합에서 i를 추가하고 싶으면, 단순히 i번째 비트의 값을 1로 변경해주면 된다.

이러한 삽입, 삭제, 조회와 같은 행위는 비트 연산을 통해 쉽게 제어할 수 있다.

 

제어를 위해 비트 연산에 대해 간략히 설명한다.

AND, OR, XOR, NOT, SHIFT 가 존재한다.

 

AND 연산(&)

대응하는 두 비트가 모두 1일 때, 1을 반환.

 

1010 & 1111 = 1010
 

OR 연산(|)

대응하는 두 비트가 모두 1 또는 하나라도 1일 때, 1을 반환.

 

1010 | 1111 = 1111
 

XOR 연산(^)

대응하는 두 비트가 서로 다르면 1을 반환.

 

1010 | 1111 = 0101
 

NOT 연산(~)

비트의 값을 반전하여 반환.

 

~1010 = 0101
 

시프트(Shift) 연산(>>, <<)

왼쪽 또는 오른쪽으로 비트를 옮긴다.

 

00001010 << 2 = 101000
00001010 >> 2 = 000010 

왼쪽 시프트는 A * 2^B 를 의미하고, 오른쪽 시프트는 A / 2^B 를 의미한다.

출처: https://mygumi.tistory.com/361 [마이구미의 HelloWorld]